# -*- coding: utf-8 -*-
"""ETL_Assessment_UsamaZaid

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OMnKeNAE0xdyyyzX6vtOwmB6a77JTJFx
"""

import requests, datetime
import pandas as pd
from pyspark.sql import SparkSession
from pyspark.sql.functions import col, lit, current_timestamp
from pyspark.sql.types import FloatType

# Initialize Spark session
spark = SparkSession.builder \
    .appName("ETL_Assessment_UsamaZaid") \
    .config("spark.jars", "/content/sample_data/mysql-connector-j-9.3.0.jar") \
    .getOrCreate()

# Load input CSV files
sales_df = spark.read.csv("/content/sample_data/sales_data_cc.csv", header=True, inferSchema=True)
product_df = spark.read.csv("/content/sample_data/product_reference.csv", header=True, inferSchema=True)

# Step 1: Clean initial data
clean_df = sales_df.dropDuplicates().na.drop(subset=["SaleAmount", "ProductID", "Currency"])

# Step 2a: Detect bad ProductIDs
invalid_product_df = clean_df.join(product_df, on="ProductID", how="left_anti") \
    .withColumn("RejectionReason", lit("ProductID not found"))

# Step 2b: Keep good ProductIDs
valid_product_df = clean_df.join(product_df, on="ProductID", how="inner")

# Step 3: Fetch conversion rates
def fetch_rates():
    try:
        res = requests.get("https://api.exchangerate-api.com/v4/latest/EUR", timeout=5)
        data = res.json()
        print("API response received successfully")
        return data.get("rates", {})
    except Exception as e:
        print("API request failed:", str(e))
        print("Using fallback exchange rates")
        return {"USD": 1.16, "GBP": 0.867, "EUR": 1.0}

rates = fetch_rates()
rate_source = "Live" if rates.get("USD", 1.16) != 1.16 else "Fallback"

# Step 4: Define currency conversion logic
def convert_to_usd(sale_amount, currency):
    try:
        rate = rates.get(currency)
        usd_rate = rates.get("USD", 1.0)
        if rate:
            return float(sale_amount) / rate * usd_rate
        else:
            return None
    except:
        return None

convert_udf = spark.udf.register("convert_to_usd", convert_to_usd, FloatType())

converted_df = valid_product_df.withColumn("SaleAmount_USD", convert_udf(col("SaleAmount"), col("Currency")))

# Step 5: Log successful conversions
log_df = converted_df.select(
    col("OrderID").alias("RecordID"),
    col("Currency").alias("OriginalCurrency"),
    col("SaleAmount_USD"),
    current_timestamp().alias("ConversionTimestamp"),
    lit(rates.get("USD", 1.16)).alias("ConversionRate"),
    lit(rate_source).alias("RateSource")
)

# Step 6a: Log failed conversions
conversion_fail_df = converted_df.filter(col("SaleAmount_USD").isNull()) \
    .withColumn("RejectionReason", lit("Currency conversion failed or invalid SaleAmount"))

# Step 6b: Union all rejected records
final_rejected_df = invalid_product_df.select("OrderID", "ProductID", "SaleAmount", "Currency", "RejectionReason") \
    .unionByName(conversion_fail_df.select("OrderID", "ProductID", "SaleAmount", "Currency", "RejectionReason")) \
    .withColumn("LoggedTimestamp", current_timestamp())

# Step 6c: Filter successful records
clean_final_df = converted_df.filter(col("SaleAmount_USD").isNotNull())

# Step 7: Evaluate rejection threshold
total_count = clean_df.count()
rejected_count = final_rejected_df.count()
error_ratio = rejected_count / total_count

# Step 8: JDBC configuration
jdbc_url = "jdbc:mysql://sql12.freesqldatabase.com:3306/sql12791174"
connection_props = {
    "user": "sql12791174",
    "password": "ehfTsN1yXX",
    "driver": "com.mysql.cj.jdbc.Driver"
}

# Step 9: Write outputs
write_successful = False

try:
    clean_final_df.write.jdbc(
        url=jdbc_url,
        table="final_cleaned_sales",
        mode="overwrite",
        properties=connection_props
    )
    log_df.write.jdbc(
        url=jdbc_url,
        table="conversion_log",
        mode="overwrite",
        properties=connection_props
    )
    final_rejected_df.write.jdbc(
        url=jdbc_url,
        table="rejected_records",
        mode="overwrite",
        properties=connection_props
    )
    write_successful = True
except Exception as e:
    print("❌ Database write failed:", str(e))

# Step 10: Final status
if write_successful:
    if error_ratio > 0.05:
        print("⛔ Pipeline aborted: error threshold exceeded.")
    else:
        print("✅ All tables written successfully.")

